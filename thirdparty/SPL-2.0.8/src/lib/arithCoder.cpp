// Copyright (c) 2013 Michael D. Adams
// All rights reserved.

// __START_OF_LICENSE__
// 
// Copyright (c) 2015 Michael D. Adams
// All rights reserved.
// 
// This file is part of the Signal Processing Library (SPL).
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3,
// or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this program; see the file LICENSE.  If not,
// see <http://www.gnu.org/licenses/>.
// 
// __END_OF_LICENSE__

#include <SPL/config.hpp>
#include <cassert>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <cmath>
#include <boost/io/ios_state.hpp>
#include <SPL/bitStream.hpp>
#include <SPL/arithCoder.hpp>

namespace SPL {

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

long double entropy(long double probability)
{
	return -(log(probability) / log(2.0));
}

////////////////////////////////////////////////////////////////////////////////
// M-ary Arithmetic Encoder Core
////////////////////////////////////////////////////////////////////////////////

int ArithEncoder::debugLevel_ = 0;
std::ostream* ArithEncoder::debugStream_ = 0;

inline int ArithEncoder::renorm()
{
	assert(low_ < high_);

	int retVal;
	for (;;) {
		assert(low_ < high_);
		if (high_ < Half) {
			if ((retVal = bitPlusFollow(0))) {
				return retVal;
			}
		} else if (low_ >= Half) {
			if ((retVal = bitPlusFollow(1))) {
				return retVal;
			}
			low_ -= Half;
			high_ -= Half;
		} else if (low_ >= FirstQuart && high_ < ThirdQuart) {
			++bitsOutstanding_;
			low_ -= FirstQuart;
			high_ -= FirstQuart;
		} else {
			break;
		}
		low_ = low_ << 1;
		high_ = (high_ << 1) | 1;
	}
	return 0;
}

ArithEncoder::ArithEncoder(OutputBitStream* out)
{
	assert(FreqBits <= CodeBits - 2);
	assert(FreqBits + CodeBits <= BigBits);

	out_ = out;
	symCount_ = 0;
	bitCount_ = 0;
	start();
}

ArithEncoder::~ArithEncoder()
{
}

int ArithEncoder::start()
{
	low_ = 0;
	high_ = MaxCode;
	bitsOutstanding_ = 0;
	return 0;
}

int ArithEncoder::encode(Freq lowFreq, Freq highFreq, Freq totalFreq)
{
	if (debugLevel_ > 0) {
		getDebugStream() << "ArithEncoder::encode(" << lowFreq << ","
		  << highFreq << "," << totalFreq << ")\n";
		dump(getDebugStream());
	}
	assert(out_->isOkay());
	assert(lowFreq < highFreq);
	assert(totalFreq <= MaxFreq);
	assert(low_ < high_);
	BigCode range;
	range = ((BigCode)(high_ - low_)) + 1;
	high_ = low_ + (range * highFreq) / totalFreq - 1;
	low_ = low_ + (range * lowFreq) / totalFreq;
	int retVal;
	if ((retVal = renorm())) {
		return retVal;
	}
	++symCount_;
	if (debugLevel_ > 0) {
		dump(getDebugStream());
	}
	return 0;
}

// Note: I am not sure if this termination algorithm is completely correct.
// It seems to work, but it may have a small probability of incorrect
// behavior.
int ArithEncoder::terminate()
{
	int retVal;
	SPL_ArithCoder_long cnt = bitCount_;
	SPL_ArithCoder_long cnt2 = bitsOutstanding_;
	++bitsOutstanding_;
	if (low_ < FirstQuart) {
		if ((retVal = bitPlusFollow(0))) {
			return retVal;
		}
	} else {
		if ((retVal = bitPlusFollow(1))) {
			return retVal;
		}
	}
	// Calculate the number of bits generated by final codeword
	// disambiguation, excluding any previously outstanding bits.
	cnt = (bitCount_ - cnt) - cnt2;
	// Output additional padding bits (which will be read by the decoder,
	// but have no effect on the decoding result).
	for (int i = 0; i < CodeBits - cnt; ++i) {
		if ((retVal = out_->putBits(0, 1))) {
			return retVal;
		}
		++bitCount_;
	}
	//cerr << "terminate() ... bitCnt=" << bitCount_ << "\n";
	return 0;
}

int ArithEncoder::bitPlusFollow(int bit)
{
	int retVal;
	if ((retVal = out_->putBits(bit, 1)) < 0) {
		return retVal;
	}
	++bitCount_;
	while (bitsOutstanding_ > 0) {
		if ((retVal = out_->putBits(!bit, 1)) < 0) {
			return retVal;
		}
		--bitsOutstanding_;
		++bitCount_;
	}
	return 0;
}

void ArithEncoder::dump(std::ostream& out) const
{
	boost::io::ios_flags_saver flags(out);
	out << "low=" << std::hex << std::showbase << low_ << " high=" << std::hex << std::showbase <<
	  high_ << " bitsOutstanding=" << bitsOutstanding_ << "\n";
}

////////////////////////////////////////////////////////////////////////////////
// M-ary Arithmetic Decoder Core
////////////////////////////////////////////////////////////////////////////////

int ArithDecoder::debugLevel_ = 0;
std::ostream* ArithDecoder::debugStream_ = 0;

inline int ArithDecoder::renorm()
{
	for (;;) {
		if (high_ < Half) {
		} else if (low_ >= Half) {
			value_ -= Half;
			low_ -= Half;
			high_ -= Half;
		} else if (low_ >= FirstQuart && high_ < ThirdQuart) {
			value_ -= FirstQuart;
			low_ -= FirstQuart;
			high_ -= FirstQuart;
		} else {
			break;
		}
		low_ <<= 1;
		high_ = (high_ << 1) | 1;
		int b;
		if ((b = in_->getBits(1)) < 0) {
			return b;
		}
		++bitCount_;
		value_ = (value_ << 1) | b;
	}
	return 0;
}

ArithDecoder::ArithDecoder(InputBitStream* in)
{
	in_ = in;
	low_ = 0;
	high_ = 0;
	value_ = 0;
	bitCount_ = 0;
	symCount_ = 0;
}

ArithDecoder::~ArithDecoder()
{
}

int ArithDecoder::start()
{
	value_ = 0;
	for (int i = 1; i <= CodeBits; i++) {
		int b;
		if ((b = in_->getBits(1)) < 0) {
			return b;
		}
		++bitCount_;
		value_ = (value_ << 1) | b;
	}
	low_ = 0;
	high_ = MaxCode;

	return 0;
}

int ArithDecoder::decode(Freq totalFreq, Freq& targetFreq)
{
	if (debugLevel_ > 0) {
		getDebugStream() << "ArithDecoder::decode(" << totalFreq << ")\n";
		dump(getDebugStream());
	}
	assert(in_->isOkay());
	assert(totalFreq <= MaxFreq);
	assert(low_ < high_);
	assert(value_ >= low_ && value_ <= high_);
	BigCode range = ((BigCode)(high_ - low_)) + 1;
    targetFreq = ((((BigCode)(value_ - low_)) + 1) * totalFreq - 1) / range;
	assert(targetFreq >= 0 && targetFreq <= totalFreq);
	++symCount_;
	return 0;
}

int ArithDecoder::adjust(Freq lowFreq, Freq highFreq, Freq totalFreq)
{
	if (debugLevel_ > 0) {
		getDebugStream() << "ArithDecoder::adjust(" << lowFreq << ","
		  << highFreq << "," << totalFreq << ")\n";
		dump(getDebugStream());
	}
	assert(in_->isOkay());
	assert(lowFreq < highFreq);
	assert(totalFreq <= MaxFreq);
	assert(low_ < high_);
	assert(value_ >= low_ && value_ <= high_);
	BigCode range;
	range = ((BigCode)(high_ - low_)) + 1;
	high_ = low_ + (range * highFreq) / totalFreq - 1;
	low_ = low_ + (range * lowFreq) / totalFreq;
	int retVal;
	if ((retVal = renorm())) {
		return retVal;
	}
	if (debugLevel_ > 0) {
		dump(getDebugStream());
	}
	return 0;
}

int ArithDecoder::terminate()
{
	//cerr << "terminate() ... bitCnt=" << bitCount_ << "\n";
	return 0;
}

void ArithDecoder::dump(std::ostream& out) const
{
	boost::io::ios_flags_saver flags(out);
	out << "low=" << std::hex << std::showbase << low_ << " high=" << std::hex << std::showbase
	  << high_ << " value=" << std::hex << std::showbase << value_ << "\n";
}

////////////////////////////////////////////////////////////////////////////////
// Probability Model
////////////////////////////////////////////////////////////////////////////////

int ArithCoderModel::debugLevel_ = 0;
std::ostream* ArithCoderModel::debugStream_ = 0;

ArithCoderModel::ArithCoderModel(int numSyms, ArithCoder::Freq maxFreq) :
  symToIdx_(std::vector<int>(numSyms)),
  idxToSym_(std::vector<int>(numSyms + 1)),
  freqs_(std::vector<ArithCoder::Freq>(numSyms + 1)),
  cumFreqs_(std::vector<ArithCoder::Freq>(numSyms + 1)),
  symCnts_(std::vector<SPL_ArithCoder_ulong>(numSyms))
{
	assert(numSyms >= 2);
	assert(maxFreq >= numSyms);
	for (int i = 0; i < numSyms; ++i) {
		symToIdx_[i] = i + 1;
		idxToSym_[i + 1] = i;
	}
	for (int i = 0; i <= numSyms; ++i) {
		freqs_[i] = 1;
		cumFreqs_[i] = numSyms - i;
	}
	freqs_[0] = 0;
	maxFreq_ = maxFreq;
	assert(cumFreqs_[0] <= maxFreq_);
	adaptive_ = true;

	for (int i = 0; i < numSyms; ++i) {
		symCnts_[i] = 0;
	}
	totalSymCnt_ = 0;

}

ArithCoderModel::~ArithCoderModel()
{
}

void ArithCoderModel::update(int sym)
{
	assert(sym >= 0 && sym < getNumSyms());
	++symCnts_[sym];
	++totalSymCnt_;
	if (!adaptive_) {
		return;
	}

	int idx = symToIdx_[sym];
	if (cumFreqs_[0] == maxFreq_) {
		ArithCoder::Freq cum = 0;
		for (int i = getNumSyms(); i >= 0; --i) {
			freqs_[i] = (freqs_[i] + 1) >> 1;
			cumFreqs_[i] = cum;
			cum += freqs_[i];
		}
	}
	int i;
	for (i = idx; freqs_[i] == freqs_[i - 1]; --i) {
	}
	if (i < idx) {
		int sym1;
		int sym2;
		sym1 = idxToSym_[i];
		sym2 = idxToSym_[idx];
		std::swap(idxToSym_[i], idxToSym_[idx]);
		std::swap(symToIdx_[sym1], symToIdx_[sym2]);
	}
	++(freqs_[i]);
	while (i > 0) {
		--i;
		++(cumFreqs_[i]);
	}
}

void ArithCoderModel::lookup(int sym, ArithCoder::Freq& lowFreq,
  ArithCoder::Freq& highFreq, ArithCoder::Freq& totalFreq) const
{
	assert(sym >= 0 && sym < getNumSyms());
	int idx = symToIdx_[sym];
	lowFreq = cumFreqs_[idx];
	highFreq = cumFreqs_[idx - 1];
	totalFreq = cumFreqs_[0];
	if (debugLevel_ > 0) {
		getDebugStream() << "lookup sym=" << sym << " ->"
		  << " lowFreq=" << lowFreq << " highFreq=" << highFreq
		  << " totalFreq=" << totalFreq << "\n";
	}
}

void ArithCoderModel::invLookup(ArithCoder::Freq targetFreq, int& sym,
  ArithCoder::Freq& lowFreq, ArithCoder::Freq& highFreq,
  ArithCoder::Freq& totalFreq) const
{
	assert(targetFreq >= 0 && targetFreq <= getTotalFreq());
	int idx;
	for (idx = 1; cumFreqs_[idx] > targetFreq; ++idx) {
	}
	assert(idx < cumFreqs_.size());
	lowFreq = cumFreqs_[idx];
	highFreq = cumFreqs_[idx - 1];
	totalFreq = cumFreqs_[0];
	sym = idxToSym_[idx];
	if (debugLevel_ > 0) {
		getDebugStream() << "invLookup targetFreq=" << targetFreq
		  << " -> sym=" << sym << " lowFreq=" << lowFreq
		  << " highFreq=" << " " << highFreq << " totalFreq=" << totalFreq
		  << "\n";
	}
}

void ArithCoderModel::dump(std::ostream& out) const
{
	for (int i = 0; i < getNumSyms(); ++i) {
		out << "symToIdx[" << i << "] = " << symToIdx_[i] << "\n";
		assert(idxToSym_[symToIdx_[i]] == i);
	}
	for (int i = 0; i < getNumSyms(); ++i) {
		out << "idxToSym[" << i << "] = " << idxToSym_[i] << "\n";
	}
	for (int i = 0; i <= getNumSyms(); ++i) {
		out << "freqs[" << i << "] = " << freqs_[i] << "\n";
	}
	for (int i = 0; i <= getNumSyms(); ++i) {
		out << "cumFreqs[" << i << "] = " << cumFreqs_[i] << "\n";
	}
}

void ArithCoderModel::setProbs(const std::vector<ArithCoder::Freq>& freqs)
{
	assert(freqs.size() == getNumSyms());
	assert(getNumSyms() == 2);
	ArithCoder::Freq mpsFreq;
	ArithCoder::Freq lpsFreq;

	if (freqs[0] > freqs[1]) {
		symToIdx_[0] = 1;
		symToIdx_[1] = 2;
		idxToSym_[2] = 1;
		idxToSym_[1] = 0;
		mpsFreq = freqs[0];
		lpsFreq = freqs[1];
	} else {
		symToIdx_[0] = 2;
		symToIdx_[1] = 1;
		idxToSym_[2] = 0;
		idxToSym_[1] = 1;
		mpsFreq = freqs[1];
		lpsFreq = freqs[0];
	}

	freqs_[0] = 0;
	freqs_[1] = mpsFreq;
	freqs_[2] = lpsFreq;
	ArithCoder::Freq sum = 0;
	for (int i = getNumSyms(); i >= 0; --i) {
		cumFreqs_[i] = sum;
		sum += freqs_[i];
	}
}

void ArithCoderModel::getProbs(std::vector<ArithCoder::Freq>& freqs)
{
	// The input vector must have the correct size.
	assert(freqs.size() == getNumSyms());

	ArithCoder::Freq cumFreq = 0;
	for (int sym = 0; sym < getNumSyms(); ++sym) {
		int ind = symToIdx_[sym];
		ArithCoder::Freq length = cumFreqs_[ind - 1] - cumFreqs_[ind];
		cumFreq += length;
		freqs[sym] = length;
	}
	assert(cumFreq == cumFreqs_[0]);
}

////////////////////////////////////////////////////////////////////////////////
// Binary Arithmetic Encoder
////////////////////////////////////////////////////////////////////////////////

std::ostream* BinArithEncoder::debugStream_ = 0;
int BinArithEncoder::debugLevel_ = 0;

BinArithEncoder::BinArithEncoder(int numContexts, OutputBitStream* out) :
  enc_(out), models_(std::vector<ArithCoderModel*>(numContexts))
{
	assert(numContexts >= 0);
	for (int i = 0; i < numContexts; ++i) {
		models_[i] = new ArithCoderModel(2, SPL_ArithCoder_DefaultMaxFreq);
	}
	bypassSymCnt_ = 0;
	bypassOneCnt_ = 0;
#if defined(SPL_ArithCoder_Entropy)
	entropy_ = 0.0;
#endif
}

BinArithEncoder::~BinArithEncoder()
{
	for (int i = 0; i < getNumContexts(); ++i) {
		delete models_[i];
	}
}

int BinArithEncoder::start()
{
	return 0;
}

int BinArithEncoder::encodeRegular(int contextId, int binVal)
{
	assert(contextId >= 0 && contextId < getNumContexts());
	assert(binVal >= 0 && binVal < 2);
	if (debugLevel_ > 0) {
		getDebugStream() << "encodeRegular " << enc_.getSymCount() << " " <<
		  contextId << " " << binVal << "\n";
	}
	ArithCoderModel& model = *(models_[contextId]);
	ArithCoder::Freq lowFreq;
	ArithCoder::Freq highFreq;
	ArithCoder::Freq totalFreq;
	model.lookup(binVal, lowFreq, highFreq, totalFreq);
	int retVal;
	if ((retVal = enc_.encode(lowFreq, highFreq, totalFreq))) {
		return retVal;
	}
#if defined(SPL_ArithCoder_Entropy)
	entropy_ += entropy(static_cast<long double>(highFreq - lowFreq) / totalFreq);
#endif
	model.update(binVal);
	return 0;
}

int BinArithEncoder::encodeBypass(int binVal)
{
	assert(binVal >= 0 && binVal < 2);
	if (debugLevel_ > 0) {
		getDebugStream() << "encodeBypass " << enc_.getSymCount() << " " <<
		  binVal << "\n";
	}
	int retVal;
	if ((retVal = enc_.encode(binVal, binVal + 1, 2))) {
		return retVal;
	}
	++bypassSymCnt_;
	if (binVal) {
		++bypassOneCnt_;
	}
#if defined(SPL_ArithCoder_Entropy)
	entropy_ += entropy(0.5);
#endif
	return 0;
}

int BinArithEncoder::terminate()
{
	return enc_.terminate();
}

void BinArithEncoder::dump(std::ostream& out) const
{
	enc_.dump(out);
}

void BinArithEncoder::dumpModels(std::ostream& out) const
{
	SPL_ArithCoder_ulong numZeros;
	SPL_ArithCoder_ulong numOnes;
	SPL_ArithCoder_ulong numSyms;
	numZeros = bypassSymCnt_ - bypassOneCnt_;
	numOnes = bypassOneCnt_;
	numSyms = bypassSymCnt_;
	out << "bypass ";
	out << std::setw(8) << 100.0 * ((double) numZeros) / numSyms << "% ";
	out << std::setw(8) << 100.0 * ((double) numOnes) / numSyms << "% ";
	out << numZeros << "/" << numSyms << " ";
	out << numOnes << "/" << numSyms << " ";
	out << "\n";
	numSyms = 0;
	for (int i = 0; i < getNumContexts(); ++i) {
		const ArithCoderModel& model = *models_[i];
		numSyms += model.getTotalSymCount();
	}
	out << "regular " << numSyms << "\n";
	for (int i = 0; i < getNumContexts(); ++i) {
		const ArithCoderModel& model = *models_[i];
		assert(model.getNumSyms() == 2);
		numSyms = model.getTotalSymCount();
		if (numSyms > 0) {
			numZeros = model.getSymCount(0);
			numOnes = model.getSymCount(1);
			assert(numZeros + numOnes == numSyms);
			out << "contextId=" << std::setw(5) << i << " ";
			out << std::setw(8) << 100.0 * ((double) numZeros) / numSyms << "% ";
			out << std::setw(8) << 100.0 * ((double) numOnes) / numSyms << "% ";
			out << numZeros << "/" << numSyms << " ";
			out << numOnes << "/" << numSyms << " ";
			out << "\n";
		}
	}
}

void BinArithEncoder::getContextStats(std::vector<BinArithCoderContextStat>&
  stats) const
{
	int numContexts = getNumContexts();
	stats = std::vector<BinArithCoderContextStat>(numContexts + 1);
	for (int i = 0; i < numContexts; ++i) {
		ArithCoderModel& model = *models_[i];
		stats[i].numOnes = model.getSymCount(1);
		stats[i].numSyms = model.getTotalSymCount();
	}
	stats[numContexts].numOnes = bypassOneCnt_;
	stats[numContexts].numSyms = bypassSymCnt_;
}

void BinArithEncoder::setContextState(int contextId, ArithCoder::Freq oneFreq,
  ArithCoder::Freq totalFreq, ArithCoder::Freq maxFreq, bool adaptive)
{
	std::vector<ArithCoder::Freq> freqs(2);
	freqs[0] = totalFreq - oneFreq;
	freqs[1] = oneFreq;
	models_[contextId]->setProbs(freqs);
	models_[contextId]->setAdaptive(adaptive);
	assert(maxFreq == SPL_ArithCoder_DefaultMaxFreq);
}

// NEW: 2015-10-23
void BinArithEncoder::getContextState(int contextId, ArithCoder::Freq& oneFreq,
  ArithCoder::Freq& totalFreq, ArithCoder::Freq& maxFreq, bool& adaptive)
{
	assert(models_[contextId]->getNumSyms() == 2);
	std::vector<ArithCoder::Freq> freqs(2);
	models_[contextId]->getProbs(freqs);
	oneFreq = freqs[1];
	totalFreq = freqs[0] + freqs[1];
	maxFreq = models_[contextId]->getMaxFreq();
	adaptive = models_[contextId]->getAdaptive();
	assert(totalFreq <= maxFreq);
}

////////////////////////////////////////////////////////////////////////////////
// Binary Arithmetic Decoder
////////////////////////////////////////////////////////////////////////////////

std::ostream* BinArithDecoder::debugStream_ = 0;
int BinArithDecoder::debugLevel_ = 0;

BinArithDecoder::BinArithDecoder(int numContexts, InputBitStream* in) :
  dec_(in), models_(std::vector<ArithCoderModel*>(numContexts))
{
	assert(numContexts >= 0);
	for (int i = 0; i < numContexts; ++i) {
		models_[i] = new ArithCoderModel(2, SPL_ArithCoder_DefaultMaxFreq);
	}
#if defined(SPL_ArithCoder_Entropy)
	entropy_ = 0.0;
#endif
}

BinArithDecoder::~BinArithDecoder()
{
	for (int i = 0; i < getNumContexts(); ++i) {
		delete models_[i];
	}
}

int BinArithDecoder::decodeRegular(int contextId)
{
	assert(contextId >= 0 && contextId < getNumContexts());
	int retVal;
	ArithCoderModel& model = *(models_[contextId]);
	ArithCoder::Freq totalFreq = model.getTotalFreq();
	ArithCoder::Freq targetFreq;
	if ((retVal = dec_.decode(totalFreq, targetFreq))) {
		assert(retVal < 0);
		return retVal;
	}
	int sym;
	ArithCoder::Freq lowFreq;
	ArithCoder::Freq highFreq;
	model.invLookup(targetFreq, sym, lowFreq, highFreq, totalFreq);
#if defined(SPL_ArithCoder_Entropy)
	entropy_ += entropy(static_cast<long double>(highFreq - lowFreq) / totalFreq);
#endif
	if ((retVal = dec_.adjust(lowFreq, highFreq, totalFreq))) {
		assert(retVal < 0);
		return retVal;
	}
	model.update(sym);
	if (debugLevel_ > 0) {
		getDebugStream() << "decodeRegular " << dec_.getSymCount() - 1 <<
		  " " << contextId << " " << sym << "\n";
	}
	return sym;
}

int BinArithDecoder::decodeBypass()
{
	int retVal;
	ArithDecoder::Freq targetFreq;
	if ((retVal = dec_.decode(2, targetFreq))) {
		return retVal;
	}
	int sym = targetFreq;
	if ((retVal = dec_.adjust(targetFreq, targetFreq + 1, 2))) {
		return retVal;
	}
	if (debugLevel_ > 0) {
		getDebugStream() << "decodeBypass " << dec_.getSymCount() - 1 << " "
		  << sym << "\n";
	}
#if defined(SPL_ArithCoder_Entropy)
	entropy_ += entropy(0.5);
#endif
	return sym;
}

int BinArithDecoder::terminate()
{
	return dec_.terminate();
}

int BinArithDecoder::start()
{
	return dec_.start();
}

void BinArithDecoder::dump(std::ostream& out) const
{
	dec_.dump(out);
}

void BinArithDecoder::setContextState(int contextId, ArithCoder::Freq oneFreq,
  ArithCoder::Freq totalFreq, ArithCoder::Freq maxFreq, bool adaptive)
{
	std::vector<ArithCoder::Freq> freqs(2);
	freqs[0] = totalFreq - oneFreq;
	freqs[1] = oneFreq;
	models_[contextId]->setProbs(freqs);
	models_[contextId]->setAdaptive(adaptive);
	assert(maxFreq == SPL_ArithCoder_DefaultMaxFreq);
}

// NEW: 2015-10-23
void BinArithDecoder::getContextState(int contextId, ArithCoder::Freq& oneFreq,
  ArithCoder::Freq& totalFreq, ArithCoder::Freq& maxFreq, bool& adaptive)
{
	assert(models_[contextId]->getNumSyms() == 2);
	std::vector<ArithCoder::Freq> freqs(2);
	models_[contextId]->getProbs(freqs);
	oneFreq = freqs[1];
	totalFreq = freqs[0] + freqs[1];
	maxFreq = models_[contextId]->getMaxFreq();
	adaptive = models_[contextId]->getAdaptive();
	assert(totalFreq <= maxFreq);
}

////////////////////////////////////////////////////////////////////////////////
// Multisymbol Arithmetic Encoder
////////////////////////////////////////////////////////////////////////////////

std::ostream* MultiArithEncoder::debugStream_ = 0;
int MultiArithEncoder::debugLevel_ = 0;

MultiArithEncoder::MultiArithEncoder(int maxContexts, OutputBitStream* out) :
  enc_(out), contexts_(maxContexts, (ArithCoderModel*)0)
{
}

MultiArithEncoder::~MultiArithEncoder()
{
	for (std::vector<ArithCoderModel*>::iterator i = contexts_.begin();
	  i != contexts_.end(); ++i) {
		if (*i) {
			delete *i;
		}
	}
}

int MultiArithEncoder::start()
{
	return enc_.start();
}

int MultiArithEncoder::terminate()
{
	return enc_.terminate();
}

int MultiArithEncoder::encodeRegular(int contextId, int sym)
{
	assert(contextId >= 0 && contextId < getMaxContexts());
	assert(contexts_[contextId]);
	ArithCoderModel& context = *(contexts_[contextId]);
	assert(sym >= 0 && sym < context.getNumSyms());
	ArithCoder::Freq lowFreq;
	ArithCoder::Freq highFreq;
	ArithCoder::Freq totalFreq;
	context.lookup(sym, lowFreq, highFreq, totalFreq);
	if (debugLevel_ > 0) {
		getDebugStream() << "MultiArithEncoder::encodeRegular{"
		  << enc_.getSymCount() << " "
		  << "contextId=" << contextId << " "
		  << "numSyms=" << context.getNumSyms() << " "
		  << "sym=" << sym
		  << "}\n";
		getDebugStream() << "__MultiArithEncoder__ "
		  << std::setw(6) << enc_.getSymCount() << " "
		  << std::setw(7) << "REGULAR" << " "
		  << std::setw(2) << contextId << " "
		  << std::setw(2) << context.getNumSyms() << " "
		  << std::setw(2) << sym
		  << "\n";
	}
	int retVal;
	if ((retVal = enc_.encode(lowFreq, highFreq, totalFreq))) {
		assert(retVal < 0);
		return retVal;
	}
	context.update(sym);
	return 0;
}

int MultiArithEncoder::encodeBypass(int numSyms, int sym)
{
	assert(numSyms >= 2);
	assert(sym >= 0 && sym < numSyms);
	if (debugLevel_ > 0) {
		getDebugStream() << "MultiArithEncoder::encodeBypass{"
		  << enc_.getSymCount() << " "
		  << "numSyms=" << numSyms << " "
		  << "sym=" << sym
		  << "}\n";
		getDebugStream() << "__MultiArithEncoder__ "
		  << std::setw(6) << enc_.getSymCount() << " "
		  << std::setw(7) << "BYPASS" << " "
		  << std::setw(2) << numSyms << " "
		  << std::setw(2) << sym
		  << "\n";
	}
	int retVal;
	if ((retVal = enc_.encode(sym, sym + 1, numSyms))) {
		return retVal;
	}
	return 0;
}

void MultiArithEncoder::dump(std::ostream& out) const
{
	enc_.dump(out);
}

void MultiArithEncoder::setContext(int contextId, int numSyms)
{
	if (debugLevel_ > 0) {
		getDebugStream() << "MultiArithEncoder::setContext("
		  << contextId << "," << numSyms << ")\n";
	}
	ArithCoderModel* context = contexts_[contextId];
	if (context) {
		delete context;
	}
	context = new ArithCoderModel(numSyms, SPL_ArithCoder_DefaultMaxFreq);
	contexts_[contextId] = context;
	context->setAdaptive(true);
}

void MultiArithEncoder::setContext(int contextId, const std::vector<ArithCoder::Freq>&
  symFreqs, bool adaptive)
{
	if (debugLevel_ > 0) {
		getDebugStream() << "MultiArithEncoder::setContext("
		  << contextId << ",XXX,YYY," << adaptive << ")\n";
	}
	ArithCoderModel* context = contexts_[contextId];
	if (context) {
		delete context;
	}
	context = new ArithCoderModel(symFreqs.size(),
	  SPL_ArithCoder_DefaultMaxFreq);
	contexts_[contextId] = context;
	context->setProbs(symFreqs);
	context->setAdaptive(adaptive);
}

////////////////////////////////////////////////////////////////////////////////
// Multisymbol Arithmetic Decoder
////////////////////////////////////////////////////////////////////////////////

std::ostream* MultiArithDecoder::debugStream_ = 0;
int MultiArithDecoder::debugLevel_ = 0;

MultiArithDecoder::MultiArithDecoder(int maxContexts, InputBitStream* in) :
  dec_(in), contexts_(maxContexts, (ArithCoderModel*)0)
{
}

MultiArithDecoder::~MultiArithDecoder()
{
	for (std::vector<ArithCoderModel*>::iterator i = contexts_.begin();
	  i != contexts_.end(); ++i) {
		if (*i) {
			delete *i;
		}
	}
}

int MultiArithDecoder::start()
{
	return dec_.start();
}

int MultiArithDecoder::terminate()
{
	return dec_.terminate();
}

int MultiArithDecoder::decodeRegular(int contextId)
{
	assert(contextId >= 0 && contextId < getMaxContexts());
	assert(contexts_[contextId]);
	ArithCoderModel& context = *contexts_[contextId];
	ArithCoder::Freq totalFreq = context.getTotalFreq();
	ArithCoder::Freq targetFreq;
	int retVal;
	if ((retVal = dec_.decode(totalFreq, targetFreq))) {
		assert(retVal < 0);
		return retVal;
	}
	int sym;
	ArithCoder::Freq lowFreq;
	ArithCoder::Freq highFreq;
	context.invLookup(targetFreq, sym, lowFreq, highFreq, totalFreq);
	if ((retVal = dec_.adjust(lowFreq, highFreq, totalFreq))) {
		assert(retVal < 0);
		return retVal;
	}
	context.update(sym);
	if (debugLevel_ > 0) {
		getDebugStream() << "MultiArithDecoder::decodeRegular{"
		  << dec_.getSymCount() - 1 << " "
		  << "contextId=" << contextId << " "
		  << "numSyms=" << context.getNumSyms() << " "
		  << "sym=" << sym
		  << "}\n";
		getDebugStream() << "__MultiArithDecoder__ "
		  << std::setw(6) << dec_.getSymCount() - 1 << " "
		  << std::setw(7) << "REGULAR" << " "
		  << std::setw(2) << contextId << " "
		  << std::setw(2) << context.getNumSyms() << " "
		  << std::setw(2) << sym
		  << "\n";
	}
	return sym;
}

int MultiArithDecoder::decodeBypass(int numSyms)
{
	assert(numSyms >= 2);
	int retVal;
	ArithDecoder::Freq targetFreq;
	if ((retVal = dec_.decode(numSyms, targetFreq))) {
		return retVal;
	}
	int sym = targetFreq;
	if ((retVal = dec_.adjust(targetFreq, targetFreq + 1, numSyms))) {
		return retVal;
	}
	if (debugLevel_ > 0) {
		getDebugStream() << "MultiArithDecoder::decodeBypass{"
		  << dec_.getSymCount() - 1 << " "
		  << "numSyms=" << numSyms << " "
		  << "sym=" << sym
		  << "}\n";
		getDebugStream() << "__MultiArithDecoder__ "
		  << std::setw(6) << dec_.getSymCount() - 1 << " "
		  << std::setw(7) << "BYPASS" << " "
		  << std::setw(2) << numSyms << " "
		  << std::setw(2) << sym
		  << "\n";
	}
	return sym;
}

void MultiArithDecoder::dump(std::ostream& out) const
{
	dec_.dump(out);
}

void MultiArithDecoder::setContext(int contextId, int numSyms)
{
	ArithCoderModel* context = contexts_[contextId];
	if (context) {
		delete context;
	}
	context = new ArithCoderModel(numSyms, SPL_ArithCoder_DefaultMaxFreq);
	contexts_[contextId] = context;
	context->setAdaptive(true);
}

void MultiArithDecoder::setContext(int contextId,
  const std::vector<ArithCoder::Freq>& symFreqs, bool adaptive)
{
	ArithCoderModel* context = contexts_[contextId];
	if (context) {
		delete context;
	}
	context = new ArithCoderModel(symFreqs.size(),
	  SPL_ArithCoder_DefaultMaxFreq);
	contexts_[contextId] = context;
	context->setProbs(symFreqs);
	context->setAdaptive(adaptive);
}

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////

}

